# v0.1 Roadmap

The following are the features, behaviors, and general requirements of `Breakfast` that must be implemented, tested, and documented for a `v0.1` release.

- [ ] Clear intent of goals and use-case
- [ ] Examples expressing both the power and simplicity
- [ ] A `Breakfast.decode/2` function that runs the decoding procedure against some params
- [ ] A `Breakfast.unwrap/1` function that returns the struct if valid, and returns the yogurt if invalid
- [ ] Only the defined function should be exposed from the `Breakfast` module
- [ ] Out of the box, a decoder should properly parse a plain, string-keyed Elixir map
- [x] Should be able to automatically support the following types:
  - Basic Types:
    - `any()`
    - `term()`
    - `atom()`
    - `map()`
    - `struct()`
    - `tuple()`
    - `float()`
    - `integer()`
    - `neg_integer()`
    - `non_neg_integer()`
    - `pos_integer()`
    - `list(type)`
    - `nonempty_list(type)`
  - Literals:
    - Atoms (`:red`, `:blue`)
    - Integers (`1`, `1..10`)
    - Lists (`[type]`, `[]`, `[...]`, `[type, ...]`, `[key: value_type]`)
    - Maps (`%{}`, `%{key: value_type}`, `%{required(key_type) => value_type}`, `%{optional(key_type) => value_type}`, `%Struct{}`, `%Struct{key: value_type}`)
    - Tuples (`{}`, `{type1, type2, ... typeN}`)
  - Built-in Types:
    - `term()`
    - `binary()`
    - `boolean()`
    - `keyword()`
    - `keyword(t)`
    - `list()`
    - `nonempty_list()`
    - `mfa()`
    - `module()`
    - `number()`
  - Union Types
  - Remote Types that resolve to a supported type
- [ ] Should support other cereals to be used as field types
- [ ] Nested cereals should have their yogurt unwrapped to its struct if valid
- [ ] Nested cereals should have their yogurt errors bubble up if invalid
- [ ] A missing value should result in a fetch error
- [ ] An uncastable value should resuilt in a cast error
- [ ] An invalid value after cast should result in a validation error
- [ ] Fields can have a custom fetch defined for them
- [ ] Fields can have a custom cast defined for them
- [ ] Fields can have a custom validate defined for them
- [ ] A default value can be provided for a field
- [ ] The default value will be used if the fetch fails for that field (makes the field optional)
- [ ] A custom fetch function can be defined at the cereal level and will be used if a field-level fetch isn't defined
- [ ] A custom cast function can be defined at the cereal level and will be used if a field-level cast isn't defined
- [ ] A helpful compile-time error should raise if invalid options are passed to the cereal call
- [ ] A helpful compile-time error should raise if invalid options are passed to the field call
- [x] A helpful compile-time error should raise if invalid options are passed to the type call
- [x] A helpful compile-time error should raise if unknown options are passed to the cereal call
- [x] A helpful compile-time error should raise if unknown options are passed to the field call
- [x] A helpful compile-time error should raise if unknown options are passed to the type call
- [ ] A helpful compile-time error should raise if a type is not understood
- [x] A helpful runtime error should raise if a fetch returns an invalid type
- [x] A helpful runtime error should raise if a cast returns an invalid type
- [x] A helpful runtime error should raise if a validate returns an invalid type
- [ ] User documentation
- [ ] Development documentation

